{
    "contents" : "################################\n#### Discriminant analysis for directional data\n#### using the k-NN alorithm, tuning the k neighbours\n#### Tsagris Michail 01/2016\n#### mtsagris@yahoo.gr\n################################\n\ndirknn.tune <- function(z, M = 10, A = 5, ina, type = \"S\",\n                        mesos = TRUE, mat = NULL) {\n  ## x is the matrix containing the data\n  ## M is the number of folds, set to 10 by default\n  ## A is the maximum number of neighbours to use\n  ## ina indicates the groups, numerical variable\n  ## type is either 'S' or 'NS'. Should the standard k-NN be use or not\n  ## if mesos is TRUE, then the arithmetic mean distange of the k nearest\n  ## points will be used.\n  ## If not, then the harmonic mean will be used. Both of these apply for\n  ## the non-standard algorithm, that is when type='NS'\n\n  runtime <- proc.time()\n  z <- as.matrix(z)  ## makes sure the x is a matrix\n  z <- z / sqrt( as.vector( Rfast::rowsums(z^2) ) ) ## makes sure the the data are unit vectors\n  n <- nrow(z)  ## sample size\n  ina <- as.numeric(ina)\n  if ( A >= min( table(ina) ) )   A <- min(table(ina)) - 3  ## The maximum\n  ## number  of nearest neighbours to use\n  ina <- as.numeric(ina) ## makes sure ina is numeric\n  ng <- max(ina)  ## The number of groups\n\n  if ( is.null(mat) ) {\n    nu <- sample(1:n, min( n, round(n / M) * M ) )\n    ## It may be the case this new nu is not exactly the same\n    ## as the one specified by the user\n    ## to a matrix a warning message should appear\n    options(warn = -1)\n    mat <- matrix( nu, ncol = M )\n  } else  mat <- mat\n\n  M <- ncol(mat)\n  per <- matrix(nrow = M, ncol = A - 1)\n  rmat <- nrow(mat)\n\n  dis <- tcrossprod( z )\n  diag(dis) <- 1\n  dis[ dis > 1 ] <- 1\n  dis <- acos(dis)\n\n  ## The k-NN algorith is calculated M times. For every repetition a\n  ## fold is chosen and its observations are classified\n  for (vim in 1:M) {\n\n    id <- as.vector( ina[ mat[, vim] ] )  ## groups of test sample\n    ina2 <- as.vector( ina[ -mat[, vim] ] )   ## groups of training sample\n    aba <- as.vector( mat[, vim] )\n    aba <- aba[aba > 0]\n    apo <- dis[-aba, aba]\n    ta <- matrix(nrow = rmat, ncol = ng)\n\n    if (type == \"NS\") {\n      ## Non Standard algorithm\n      for ( j in 1:c(A - 1) ) {\n        knn <- j + 1\n        for (l in 1:ng) {\n          dista <- apo[ina2 == l, ]\n          dista <- Rfast::sort_mat(dista)\n          if (mesos == TRUE) {\n            ta[, l] <- as.vector( Rfast::colmeans( dista[1:knn, ] ) )\n          } else {\n            ta[, l] <- knn / as.vector( Rfast::colsums( 1 / dista[1:knn, ] ) )\n          }\n        }\n        g <- max.col(-ta)\n        per[vim, j] <- sum( g == id ) / rmat\n      }\n\n    } else {\n      ## Standard algorithm\n      g <- numeric( rmat )\n      for ( j in 1:c(A - 1) ) {\n        knn <- j + 1\n        for (k in 1:rmat) {\n          xa <- cbind(ina2, apo[, k])\n          qan <- xa[order(xa[, 2]), ]\n          sa <- qan[1:knn, 1]\n          tab <- table(sa)\n          g[k] <- as.integer( names(tab)[ which.max(tab) ] )\n        }\n        per[vim, j] <- sum( g == id ) / rmat\n      }\n    }\n  }\n\n  ela <- as.vector( Rfast::colmeans(per) )\n  bias <- per[ , which.max(ela)] - apply(per, 1, max)  ## TT estimate of bias\n  estb <- mean( bias )  ## TT estimate of bias\n  runtime <- proc.time() - runtime\n  names(ela) <- paste(\"k=\", 2:A, sep = \"\")\n  plot(2:A, ela, type = \"b\", xlab = \"k nearest neighbours\",\n       pch = 9, ylab = \"Estimated percentage of correct classification\")\n  percent <- c( max(ela) + estb)\n  names(percent) <- c(\"Bias corrected estimated percentage\")\n\n  list( per = ela, percent = percent, runtime = runtime )\n}\n",
    "created" : 1472324689999.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "89326496",
    "id" : "42734438",
    "lastKnownWriteTime" : 1472377304,
    "path" : "D:/paketo/Directional statistics/Directional/R/dirknn.tune.R",
    "project_path" : "R/dirknn.tune.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}